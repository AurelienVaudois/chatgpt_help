import numpy as np
from sklearn.datasets import make_multilabel_classification
from sklearn.utils import resample

# Paramètres du jeu de données
nombre_labels = 42
exemples_par_label = 50
nombre_total_exemples = nombre_labels * exemples_par_label

# Génération des données initiales
X, y = make_multilabel_classification(
    n_samples=nombre_total_exemples,
    n_features=10,  # Nombre de caractéristiques par exemple
    n_classes=nombre_labels,
    n_labels=5,  # Nombre moyen de labels actifs par exemple
    random_state=42
)

# Compter le nombre d'exemples par label
nombre_exemples_par_label = np.sum(y, axis=0)

# Déterminer le nombre minimal d'exemples par label
nombre_min_exemples = np.min(nombre_exemples_par_label)

# Sous-échantillonnage équilibré par label
X_sous_echantillon = []
y_sous_echantillon = []
for label in range(nombre_labels):
    # Sélectionner les indices des exemples du label actuel
    indices_label = np.where(y[:, label] == 1)[0]
    # Sous-échantillonner les exemples pour atteindre le nombre minimal
    indices_sous_echantillon = resample(indices_label, replace=False, n_samples=nombre_min_exemples, random_state=42)
    # Ajouter les exemples sous-échantillonnés aux données finales
    X_sous_echantillon.extend(X[indices_sous_echantillon])
    y_sous_echantillon.extend(y[indices_sous_echantillon])

# Convertir les données en tableaux numpy
X_sous_echantillon = np.array(X_sous_echantillon)
y_sous_echantillon = np.array(y_sous_echantillon)

# Affichage des dimensions des données sous-échantillonnées
print("Dimensions de X_sous_echantillon :", X_sous_echantillon.shape)
print("Dimensions de y_sous_echantillon :", y_sous_echantillon.shape)
